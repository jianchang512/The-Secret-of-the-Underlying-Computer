<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>24.彻底理解树的递归遍历 | 计算机底层的秘密</title>
    <meta name="description" content="计算机底层的秘密">
    <link rel="preload stylesheet" href="/assets/style.47519a3e.css" as="style">
    
    <script type="module" src="/assets/app.a08b5118.js"></script>
    <link rel="preload" href="/assets/inter-roman-latin.2ed14f66.woff2" as="font" type="font/woff2" crossorigin="">
    <link rel="modulepreload" href="/assets/chunks/framework.bf97371d.js">
    <link rel="modulepreload" href="/assets/chunks/theme.45a5731d.js">
    <link rel="modulepreload" href="/assets/24.-che-di-li-jie-shu-de-di-gui-bian-li.md.16408148.lean.js">
    <script id="check-dark-mode">(()=>{const e=localStorage.getItem("vitepress-theme-appearance")||"auto",a=window.matchMedia("(prefers-color-scheme: dark)").matches;(!e||e==="auto"?a:e==="dark")&&document.documentElement.classList.add("dark")})();</script>
    <script id="check-mac-os">document.documentElement.classList.toggle("mac",/Mac|iPhone|iPod|iPad/i.test(navigator.platform));</script>
  </head>
  <body>
    <div id="app"><div class="Layout" data-v-5a346dfe><!--[--><!--]--><!--[--><span tabindex="-1" data-v-0f60ec36></span><a href="#VPContent" class="VPSkipLink visually-hidden" data-v-0f60ec36> Skip to content </a><!--]--><!----><header class="VPNav" data-v-5a346dfe data-v-ae24b3ad><div class="VPNavBar has-sidebar" data-v-ae24b3ad data-v-a0fd61f4><div class="container" data-v-a0fd61f4><div class="title" data-v-a0fd61f4><div class="VPNavBarTitle has-sidebar" data-v-a0fd61f4 data-v-86d1bed8><a class="title" href="/" data-v-86d1bed8><!--[--><!--]--><!--[--><img class="VPImage logo" src="/logo.jpg" alt data-v-8426fc1a><!--]--><!--[-->计算机底层的秘密<!--]--><!--[--><!--]--></a></div></div><div class="content" data-v-a0fd61f4><div class="curtain" data-v-a0fd61f4></div><div class="content-body" data-v-a0fd61f4><!--[--><!--]--><div class="VPNavBarSearch search" data-v-a0fd61f4><!----></div><nav aria-labelledby="main-nav-aria-label" class="VPNavBarMenu menu" data-v-a0fd61f4 data-v-7f418b0f><span id="main-nav-aria-label" class="visually-hidden" data-v-7f418b0f>Main Navigation</span><!--[--><!--[--><a class="VPLink link VPNavBarMenuLink" href="/" tabindex="0" data-v-7f418b0f data-v-42ef59de><!--[--><span data-v-42ef59de>首页</span><!--]--></a><!--]--><!--[--><a class="VPLink link VPNavBarMenuLink" href="/SUMMARY.html" tabindex="0" data-v-7f418b0f data-v-42ef59de><!--[--><span data-v-42ef59de>阅读</span><!--]--></a><!--]--><!--[--><a class="VPLink link vp-external-link-icon VPNavBarMenuLink" href="https://www.wonyes.org" target="_blank" rel="noreferrer" tabindex="0" data-v-7f418b0f data-v-42ef59de><!--[--><span data-v-42ef59de>原创画作</span><!--]--></a><!--]--><!--]--></nav><!----><div class="VPNavBarAppearance appearance" data-v-a0fd61f4 data-v-e6aabb21><button class="VPSwitch VPSwitchAppearance" type="button" role="switch" title="toggle dark mode" aria-checked="false" data-v-e6aabb21 data-v-ce54a7d1 data-v-b1685198><span class="check" data-v-b1685198><span class="icon" data-v-b1685198><!--[--><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" viewbox="0 0 24 24" class="sun" data-v-ce54a7d1><path d="M12,18c-3.3,0-6-2.7-6-6s2.7-6,6-6s6,2.7,6,6S15.3,18,12,18zM12,8c-2.2,0-4,1.8-4,4c0,2.2,1.8,4,4,4c2.2,0,4-1.8,4-4C16,9.8,14.2,8,12,8z"></path><path d="M12,4c-0.6,0-1-0.4-1-1V1c0-0.6,0.4-1,1-1s1,0.4,1,1v2C13,3.6,12.6,4,12,4z"></path><path d="M12,24c-0.6,0-1-0.4-1-1v-2c0-0.6,0.4-1,1-1s1,0.4,1,1v2C13,23.6,12.6,24,12,24z"></path><path d="M5.6,6.6c-0.3,0-0.5-0.1-0.7-0.3L3.5,4.9c-0.4-0.4-0.4-1,0-1.4s1-0.4,1.4,0l1.4,1.4c0.4,0.4,0.4,1,0,1.4C6.2,6.5,5.9,6.6,5.6,6.6z"></path><path d="M19.8,20.8c-0.3,0-0.5-0.1-0.7-0.3l-1.4-1.4c-0.4-0.4-0.4-1,0-1.4s1-0.4,1.4,0l1.4,1.4c0.4,0.4,0.4,1,0,1.4C20.3,20.7,20,20.8,19.8,20.8z"></path><path d="M3,13H1c-0.6,0-1-0.4-1-1s0.4-1,1-1h2c0.6,0,1,0.4,1,1S3.6,13,3,13z"></path><path d="M23,13h-2c-0.6,0-1-0.4-1-1s0.4-1,1-1h2c0.6,0,1,0.4,1,1S23.6,13,23,13z"></path><path d="M4.2,20.8c-0.3,0-0.5-0.1-0.7-0.3c-0.4-0.4-0.4-1,0-1.4l1.4-1.4c0.4-0.4,1-0.4,1.4,0s0.4,1,0,1.4l-1.4,1.4C4.7,20.7,4.5,20.8,4.2,20.8z"></path><path d="M18.4,6.6c-0.3,0-0.5-0.1-0.7-0.3c-0.4-0.4-0.4-1,0-1.4l1.4-1.4c0.4-0.4,1-0.4,1.4,0s0.4,1,0,1.4l-1.4,1.4C18.9,6.5,18.6,6.6,18.4,6.6z"></path></svg><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" viewbox="0 0 24 24" class="moon" data-v-ce54a7d1><path d="M12.1,22c-0.3,0-0.6,0-0.9,0c-5.5-0.5-9.5-5.4-9-10.9c0.4-4.8,4.2-8.6,9-9c0.4,0,0.8,0.2,1,0.5c0.2,0.3,0.2,0.8-0.1,1.1c-2,2.7-1.4,6.4,1.3,8.4c2.1,1.6,5,1.6,7.1,0c0.3-0.2,0.7-0.3,1.1-0.1c0.3,0.2,0.5,0.6,0.5,1c-0.2,2.7-1.5,5.1-3.6,6.8C16.6,21.2,14.4,22,12.1,22zM9.3,4.4c-2.9,1-5,3.6-5.2,6.8c-0.4,4.4,2.8,8.3,7.2,8.7c2.1,0.2,4.2-0.4,5.8-1.8c1.1-0.9,1.9-2.1,2.4-3.4c-2.5,0.9-5.3,0.5-7.5-1.1C9.2,11.4,8.1,7.7,9.3,4.4z"></path></svg><!--]--></span></span></button></div><div class="VPSocialLinks VPNavBarSocialLinks social-links" data-v-a0fd61f4 data-v-0394ad82 data-v-7bc22406><!--[--><a class="VPSocialLink no-icon" href="https://github.com/jianchang512/gitbook" aria-label="github" target="_blank" rel="noopener" data-v-7bc22406 data-v-f80f8133><svg role="img" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><title>GitHub</title><path d="M12 .297c-6.63 0-12 5.373-12 12 0 5.303 3.438 9.8 8.205 11.385.6.113.82-.258.82-.577 0-.285-.01-1.04-.015-2.04-3.338.724-4.042-1.61-4.042-1.61C4.422 18.07 3.633 17.7 3.633 17.7c-1.087-.744.084-.729.084-.729 1.205.084 1.838 1.236 1.838 1.236 1.07 1.835 2.809 1.305 3.495.998.108-.776.417-1.305.76-1.605-2.665-.3-5.466-1.332-5.466-5.93 0-1.31.465-2.38 1.235-3.22-.135-.303-.54-1.523.105-3.176 0 0 1.005-.322 3.3 1.23.96-.267 1.98-.399 3-.405 1.02.006 2.04.138 3 .405 2.28-1.552 3.285-1.23 3.285-1.23.645 1.653.24 2.873.12 3.176.765.84 1.23 1.91 1.23 3.22 0 4.61-2.805 5.625-5.475 5.92.42.36.81 1.096.81 2.22 0 1.606-.015 2.896-.015 3.286 0 .315.21.69.825.57C20.565 22.092 24 17.592 24 12.297c0-6.627-5.373-12-12-12"/></svg></a><!--]--></div><div class="VPFlyout VPNavBarExtra extra" data-v-a0fd61f4 data-v-40855f84 data-v-9c007e85><button type="button" class="button" aria-haspopup="true" aria-expanded="false" aria-label="extra navigation" data-v-9c007e85><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" viewbox="0 0 24 24" class="icon" data-v-9c007e85><circle cx="12" cy="12" r="2"></circle><circle cx="19" cy="12" r="2"></circle><circle cx="5" cy="12" r="2"></circle></svg></button><div class="menu" data-v-9c007e85><div class="VPMenu" data-v-9c007e85 data-v-e7ea1737><!----><!--[--><!--[--><!----><div class="group" data-v-40855f84><div class="item appearance" data-v-40855f84><p class="label" data-v-40855f84>Appearance</p><div class="appearance-action" data-v-40855f84><button class="VPSwitch VPSwitchAppearance" type="button" role="switch" title="toggle dark mode" aria-checked="false" data-v-40855f84 data-v-ce54a7d1 data-v-b1685198><span class="check" data-v-b1685198><span class="icon" data-v-b1685198><!--[--><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" viewbox="0 0 24 24" class="sun" data-v-ce54a7d1><path d="M12,18c-3.3,0-6-2.7-6-6s2.7-6,6-6s6,2.7,6,6S15.3,18,12,18zM12,8c-2.2,0-4,1.8-4,4c0,2.2,1.8,4,4,4c2.2,0,4-1.8,4-4C16,9.8,14.2,8,12,8z"></path><path d="M12,4c-0.6,0-1-0.4-1-1V1c0-0.6,0.4-1,1-1s1,0.4,1,1v2C13,3.6,12.6,4,12,4z"></path><path d="M12,24c-0.6,0-1-0.4-1-1v-2c0-0.6,0.4-1,1-1s1,0.4,1,1v2C13,23.6,12.6,24,12,24z"></path><path d="M5.6,6.6c-0.3,0-0.5-0.1-0.7-0.3L3.5,4.9c-0.4-0.4-0.4-1,0-1.4s1-0.4,1.4,0l1.4,1.4c0.4,0.4,0.4,1,0,1.4C6.2,6.5,5.9,6.6,5.6,6.6z"></path><path d="M19.8,20.8c-0.3,0-0.5-0.1-0.7-0.3l-1.4-1.4c-0.4-0.4-0.4-1,0-1.4s1-0.4,1.4,0l1.4,1.4c0.4,0.4,0.4,1,0,1.4C20.3,20.7,20,20.8,19.8,20.8z"></path><path d="M3,13H1c-0.6,0-1-0.4-1-1s0.4-1,1-1h2c0.6,0,1,0.4,1,1S3.6,13,3,13z"></path><path d="M23,13h-2c-0.6,0-1-0.4-1-1s0.4-1,1-1h2c0.6,0,1,0.4,1,1S23.6,13,23,13z"></path><path d="M4.2,20.8c-0.3,0-0.5-0.1-0.7-0.3c-0.4-0.4-0.4-1,0-1.4l1.4-1.4c0.4-0.4,1-0.4,1.4,0s0.4,1,0,1.4l-1.4,1.4C4.7,20.7,4.5,20.8,4.2,20.8z"></path><path d="M18.4,6.6c-0.3,0-0.5-0.1-0.7-0.3c-0.4-0.4-0.4-1,0-1.4l1.4-1.4c0.4-0.4,1-0.4,1.4,0s0.4,1,0,1.4l-1.4,1.4C18.9,6.5,18.6,6.6,18.4,6.6z"></path></svg><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" viewbox="0 0 24 24" class="moon" data-v-ce54a7d1><path d="M12.1,22c-0.3,0-0.6,0-0.9,0c-5.5-0.5-9.5-5.4-9-10.9c0.4-4.8,4.2-8.6,9-9c0.4,0,0.8,0.2,1,0.5c0.2,0.3,0.2,0.8-0.1,1.1c-2,2.7-1.4,6.4,1.3,8.4c2.1,1.6,5,1.6,7.1,0c0.3-0.2,0.7-0.3,1.1-0.1c0.3,0.2,0.5,0.6,0.5,1c-0.2,2.7-1.5,5.1-3.6,6.8C16.6,21.2,14.4,22,12.1,22zM9.3,4.4c-2.9,1-5,3.6-5.2,6.8c-0.4,4.4,2.8,8.3,7.2,8.7c2.1,0.2,4.2-0.4,5.8-1.8c1.1-0.9,1.9-2.1,2.4-3.4c-2.5,0.9-5.3,0.5-7.5-1.1C9.2,11.4,8.1,7.7,9.3,4.4z"></path></svg><!--]--></span></span></button></div></div></div><div class="group" data-v-40855f84><div class="item social-links" data-v-40855f84><div class="VPSocialLinks social-links-list" data-v-40855f84 data-v-7bc22406><!--[--><a class="VPSocialLink no-icon" href="https://github.com/jianchang512/gitbook" aria-label="github" target="_blank" rel="noopener" data-v-7bc22406 data-v-f80f8133><svg role="img" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><title>GitHub</title><path d="M12 .297c-6.63 0-12 5.373-12 12 0 5.303 3.438 9.8 8.205 11.385.6.113.82-.258.82-.577 0-.285-.01-1.04-.015-2.04-3.338.724-4.042-1.61-4.042-1.61C4.422 18.07 3.633 17.7 3.633 17.7c-1.087-.744.084-.729.084-.729 1.205.084 1.838 1.236 1.838 1.236 1.07 1.835 2.809 1.305 3.495.998.108-.776.417-1.305.76-1.605-2.665-.3-5.466-1.332-5.466-5.93 0-1.31.465-2.38 1.235-3.22-.135-.303-.54-1.523.105-3.176 0 0 1.005-.322 3.3 1.23.96-.267 1.98-.399 3-.405 1.02.006 2.04.138 3 .405 2.28-1.552 3.285-1.23 3.285-1.23.645 1.653.24 2.873.12 3.176.765.84 1.23 1.91 1.23 3.22 0 4.61-2.805 5.625-5.475 5.92.42.36.81 1.096.81 2.22 0 1.606-.015 2.896-.015 3.286 0 .315.21.69.825.57C20.565 22.092 24 17.592 24 12.297c0-6.627-5.373-12-12-12"/></svg></a><!--]--></div></div></div><!--]--><!--]--></div></div></div><!--[--><!--]--><button type="button" class="VPNavBarHamburger hamburger" aria-label="mobile navigation" aria-expanded="false" aria-controls="VPNavScreen" data-v-a0fd61f4 data-v-e5dd9c1c><span class="container" data-v-e5dd9c1c><span class="top" data-v-e5dd9c1c></span><span class="middle" data-v-e5dd9c1c></span><span class="bottom" data-v-e5dd9c1c></span></span></button></div></div></div></div><!----></header><div class="VPLocalNav reached-top" data-v-5a346dfe data-v-79c8c1df><button class="menu" aria-expanded="false" aria-controls="VPSidebarNav" data-v-79c8c1df><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" viewbox="0 0 24 24" class="menu-icon" data-v-79c8c1df><path d="M17,11H3c-0.6,0-1-0.4-1-1s0.4-1,1-1h14c0.6,0,1,0.4,1,1S17.6,11,17,11z"></path><path d="M21,7H3C2.4,7,2,6.6,2,6s0.4-1,1-1h18c0.6,0,1,0.4,1,1S21.6,7,21,7z"></path><path d="M21,15H3c-0.6,0-1-0.4-1-1s0.4-1,1-1h18c0.6,0,1,0.4,1,1S21.6,15,21,15z"></path><path d="M17,19H3c-0.6,0-1-0.4-1-1s0.4-1,1-1h14c0.6,0,1,0.4,1,1S17.6,19,17,19z"></path></svg><span class="menu-text" data-v-79c8c1df>Menu</span></button><div class="VPLocalNavOutlineDropdown" style="--vp-vh:0px;" data-v-79c8c1df data-v-1c15a60a><button data-v-1c15a60a>Return to top</button><!----></div></div><aside class="VPSidebar" data-v-5a346dfe data-v-b00e2fdd><div class="curtain" data-v-b00e2fdd></div><nav class="nav" id="VPSidebarNav" aria-labelledby="sidebar-aria-label" tabindex="-1" data-v-b00e2fdd><span class="visually-hidden" id="sidebar-aria-label" data-v-b00e2fdd> Sidebar Navigation </span><!--[--><!--]--><!--[--><div class="group" data-v-b00e2fdd><section class="VPSidebarItem level-0" data-v-b00e2fdd data-v-e31bd47b><div class="item" role="button" tabindex="0" data-v-e31bd47b><div class="indicator" data-v-e31bd47b></div><h2 class="text" data-v-e31bd47b>目录</h2><!----></div><div class="items" data-v-e31bd47b><!--[--><div class="VPSidebarItem level-1 is-link" data-v-e31bd47b data-v-e31bd47b><div class="item" data-v-e31bd47b><div class="indicator" data-v-e31bd47b></div><a class="VPLink link link" href="/1.-ni-guan-zhe-po-wan-yi-jiao-cpu.html" data-v-e31bd47b><!--[--><p class="text" data-v-e31bd47b>1.你管这破玩意叫CPU？</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-e31bd47b data-v-e31bd47b><div class="item" data-v-e31bd47b><div class="indicator" data-v-e31bd47b></div><a class="VPLink link link" href="/2.-ni-guan-zhe-po-wan-yi-jiao-xian-cheng.html" data-v-e31bd47b><!--[--><p class="text" data-v-e31bd47b>2.你管这破玩意叫线程？</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-e31bd47b data-v-e31bd47b><div class="item" data-v-e31bd47b><div class="indicator" data-v-e31bd47b></div><a class="VPLink link link" href="/3.-zhi-hang-io-cao-zuo-shi-di-ceng-fa-sheng-le-shi-mo.html" data-v-e31bd47b><!--[--><p class="text" data-v-e31bd47b>3.执行I/O操作时底层发生了什么？</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-e31bd47b data-v-e31bd47b><div class="item" data-v-e31bd47b><div class="indicator" data-v-e31bd47b></div><a class="VPLink link link" href="/4.-cong-xiao-bai-dao-gao-shou-ni-xu-yao-li-jie-tong-bu-yu-yi-bu.html" data-v-e31bd47b><!--[--><p class="text" data-v-e31bd47b>4.从小白到高手，你需要理解同步与异步</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-e31bd47b data-v-e31bd47b><div class="item" data-v-e31bd47b><div class="indicator" data-v-e31bd47b></div><a class="VPLink link link" href="/5.-ni-guan-zhe-po-wan-yi-jiao-io-duo-lu-fu-yong.html" data-v-e31bd47b><!--[--><p class="text" data-v-e31bd47b>5.你管这破玩意叫IO多路复用？</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-e31bd47b data-v-e31bd47b><div class="item" data-v-e31bd47b><div class="indicator" data-v-e31bd47b></div><a class="VPLink link link" href="/6.cpu-shi-ru-he-li-jie-01-er-jin-zhi-de.html" data-v-e31bd47b><!--[--><p class="text" data-v-e31bd47b>6.CPU是如何理解01二进制的？</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-e31bd47b data-v-e31bd47b><div class="item" data-v-e31bd47b><div class="indicator" data-v-e31bd47b></div><a class="VPLink link link" href="/7.cpu-kong-xian-shi-zai-gan-ma.html" data-v-e31bd47b><!--[--><p class="text" data-v-e31bd47b>7.CPU空闲时在干嘛？</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-e31bd47b data-v-e31bd47b><div class="item" data-v-e31bd47b><div class="indicator" data-v-e31bd47b></div><a class="VPLink link link" href="/8.-bian-yi-qi-shi-ru-he-gong-zuo-de.html" data-v-e31bd47b><!--[--><p class="text" data-v-e31bd47b>8.编译器是如何工作的？</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-e31bd47b data-v-e31bd47b><div class="item" data-v-e31bd47b><div class="indicator" data-v-e31bd47b></div><a class="VPLink link link" href="/9.-han-shu-yun-hang-shi-zai-nei-cun-zhong-shi-shi-mo-yang-zi.html" data-v-e31bd47b><!--[--><p class="text" data-v-e31bd47b>9.函数运行时在内存中是什么样子？</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-e31bd47b data-v-e31bd47b><div class="item" data-v-e31bd47b><div class="indicator" data-v-e31bd47b></div><a class="VPLink link link" href="/10.-che-di-li-jie-hui-tiao-han-shu.html" data-v-e31bd47b><!--[--><p class="text" data-v-e31bd47b>10.彻底理解回调函数</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-e31bd47b data-v-e31bd47b><div class="item" data-v-e31bd47b><div class="indicator" data-v-e31bd47b></div><a class="VPLink link link" href="/11.-zi-ji-dong-shou-shi-xian-malloc-nei-cun-fen-pei-qi.html" data-v-e31bd47b><!--[--><p class="text" data-v-e31bd47b>11.自己动手实现malloc内存分配器</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-e31bd47b data-v-e31bd47b><div class="item" data-v-e31bd47b><div class="indicator" data-v-e31bd47b></div><a class="VPLink link link" href="/12.-xian-cheng-chi-shi-ru-he-shi-xian-de.html" data-v-e31bd47b><!--[--><p class="text" data-v-e31bd47b>12.线程池是如何实现的？</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-e31bd47b data-v-e31bd47b><div class="item" data-v-e31bd47b><div class="indicator" data-v-e31bd47b></div><a class="VPLink link link" href="/13.-xian-cheng-an-quan-dai-ma-dao-di-shi-zen-mo-bian-xie-de.html" data-v-e31bd47b><!--[--><p class="text" data-v-e31bd47b>13.线程安全代码到底是怎么编写的？</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-e31bd47b data-v-e31bd47b><div class="item" data-v-e31bd47b><div class="indicator" data-v-e31bd47b></div><a class="VPLink link link" href="/14.-cheng-xu-yuan-ying-ru-he-li-jie-xie-cheng.html" data-v-e31bd47b><!--[--><p class="text" data-v-e31bd47b>14.程序员应如何理解协程</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-e31bd47b data-v-e31bd47b><div class="item" data-v-e31bd47b><div class="indicator" data-v-e31bd47b></div><a class="VPLink link link" href="/15.-shi-ge-nei-cun-yin-fa-de-da-keng.html" data-v-e31bd47b><!--[--><p class="text" data-v-e31bd47b>15.十个内存引发的大坑</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-e31bd47b data-v-e31bd47b><div class="item" data-v-e31bd47b><div class="indicator" data-v-e31bd47b></div><a class="VPLink link link" href="/16.cpu-shi-ru-he-du-xie-nei-cun-de.html" data-v-e31bd47b><!--[--><p class="text" data-v-e31bd47b>16.CPU是如何读写内存的？</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-e31bd47b data-v-e31bd47b><div class="item" data-v-e31bd47b><div class="indicator" data-v-e31bd47b></div><a class="VPLink link link" href="/17.cpu-yu-fen-zhi-yu-ce.html" data-v-e31bd47b><!--[--><p class="text" data-v-e31bd47b>17.CPU与分支预测</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-e31bd47b data-v-e31bd47b><div class="item" data-v-e31bd47b><div class="indicator" data-v-e31bd47b></div><a class="VPLink link link" href="/18.cpu-jin-hua-lun-fu-za-zhi-ling-ji-de-dan-sheng.html" data-v-e31bd47b><!--[--><p class="text" data-v-e31bd47b>18.CPU进化论：复杂指令集的诞生</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-e31bd47b data-v-e31bd47b><div class="item" data-v-e31bd47b><div class="indicator" data-v-e31bd47b></div><a class="VPLink link link" href="/19.cpu-jin-hua-lun-jing-jian-zhi-ling-ji-de-dan-sheng.html" data-v-e31bd47b><!--[--><p class="text" data-v-e31bd47b>19.CPU进化论：精简指令集的诞生</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-e31bd47b data-v-e31bd47b><div class="item" data-v-e31bd47b><div class="indicator" data-v-e31bd47b></div><a class="VPLink link link" href="/20.cpu-he-shu-yu-xian-cheng-shu-you-shi-mo-guan-xi.html" data-v-e31bd47b><!--[--><p class="text" data-v-e31bd47b>20.CPU核数与线程数有什么关系？</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-e31bd47b data-v-e31bd47b><div class="item" data-v-e31bd47b><div class="indicator" data-v-e31bd47b></div><a class="VPLink link link" href="/21.-ni-guan-zhe-po-wan-yi-jiao-mmap.html" data-v-e31bd47b><!--[--><p class="text" data-v-e31bd47b>21.你管这破玩意叫mmap？</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-e31bd47b data-v-e31bd47b><div class="item" data-v-e31bd47b><div class="indicator" data-v-e31bd47b></div><a class="VPLink link link" href="/22.-che-di-li-jie-ling-kao-bei.html" data-v-e31bd47b><!--[--><p class="text" data-v-e31bd47b>22.彻底理解零拷贝</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-e31bd47b data-v-e31bd47b><div class="item" data-v-e31bd47b><div class="indicator" data-v-e31bd47b></div><a class="VPLink link link" href="/23.-cao-zuo-xi-tong-yu-nei-he-you-shi-mo-qu-bie.html" data-v-e31bd47b><!--[--><p class="text" data-v-e31bd47b>23.操作系统与内核有什么区别？</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-e31bd47b data-v-e31bd47b><div class="item" data-v-e31bd47b><div class="indicator" data-v-e31bd47b></div><a class="VPLink link link" href="/24.-che-di-li-jie-shu-de-di-gui-bian-li.html" data-v-e31bd47b><!--[--><p class="text" data-v-e31bd47b>24.彻底理解树的递归遍历</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-e31bd47b data-v-e31bd47b><div class="item" data-v-e31bd47b><div class="indicator" data-v-e31bd47b></div><a class="VPLink link link" href="/25.cpu-ji-cun-qi-shi-ru-he-zhuang-ru-jie-gou-ti-de.html" data-v-e31bd47b><!--[--><p class="text" data-v-e31bd47b>25.CPU寄存器是如何装入结构体的？</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-e31bd47b data-v-e31bd47b><div class="item" data-v-e31bd47b><div class="indicator" data-v-e31bd47b></div><a class="VPLink link link" href="/26.cpu-ke-yi-pao-duo-kuai-cong-di-qiu-dao-huo-xing-de-ju-li-gao-su-ni.html" data-v-e31bd47b><!--[--><p class="text" data-v-e31bd47b>26.CPU可以跑多快？从地球到火星的距离告诉你</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-e31bd47b data-v-e31bd47b><div class="item" data-v-e31bd47b><div class="indicator" data-v-e31bd47b></div><a class="VPLink link link" href="/27.-hui-tiao-han-shu-shi-xian-de-yuan-li-shi-shi-mo.html" data-v-e31bd47b><!--[--><p class="text" data-v-e31bd47b>27.回调函数实现的原理是什么？</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-e31bd47b data-v-e31bd47b><div class="item" data-v-e31bd47b><div class="indicator" data-v-e31bd47b></div><a class="VPLink link link" href="/28.-cheng-xu-yuan-huan-xu-yao-li-jie-hui-bian-ma.html" data-v-e31bd47b><!--[--><p class="text" data-v-e31bd47b>28.程序员还需要理解汇编吗？</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-e31bd47b data-v-e31bd47b><div class="item" data-v-e31bd47b><div class="indicator" data-v-e31bd47b></div><a class="VPLink link link" href="/29.-shi-mo-shi-yi-bu-bian-cheng.html" data-v-e31bd47b><!--[--><p class="text" data-v-e31bd47b>29.什么是异步编程？</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-e31bd47b data-v-e31bd47b><div class="item" data-v-e31bd47b><div class="indicator" data-v-e31bd47b></div><a class="VPLink link link" href="/30.-che-di-li-jiecyu-yan-zhong-de-zhi-zhen.html" data-v-e31bd47b><!--[--><p class="text" data-v-e31bd47b>30.彻底理解C语言中的指针</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-e31bd47b data-v-e31bd47b><div class="item" data-v-e31bd47b><div class="indicator" data-v-e31bd47b></div><a class="VPLink link link" href="/31.-cheng-xu-yuan-ying-ru-he-li-jie-biao-zhun-ku.html" data-v-e31bd47b><!--[--><p class="text" data-v-e31bd47b>31.程序员应如何理解标准库</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-e31bd47b data-v-e31bd47b><div class="item" data-v-e31bd47b><div class="indicator" data-v-e31bd47b></div><a class="VPLink link link" href="/32.-cheng-xu-yuan-ying-ru-he-li-jie-tou-wen-jian.html" data-v-e31bd47b><!--[--><p class="text" data-v-e31bd47b>32.程序员应如何理解头文件？</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-e31bd47b data-v-e31bd47b><div class="item" data-v-e31bd47b><div class="indicator" data-v-e31bd47b></div><a class="VPLink link link" href="/33.-cheng-xu-yuan-ying-ru-he-li-jie-duo-tai.html" data-v-e31bd47b><!--[--><p class="text" data-v-e31bd47b>33.程序员应如何理解多态？</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-e31bd47b data-v-e31bd47b><div class="item" data-v-e31bd47b><div class="indicator" data-v-e31bd47b></div><a class="VPLink link link" href="/34.-wei-shi-mo-chou-xiang-zai-ji-suan-ji-ke-xue-zhong-ru-ci-zhong-yao.html" data-v-e31bd47b><!--[--><p class="text" data-v-e31bd47b>34.为什么抽象在计算机科学中如此重要？</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-e31bd47b data-v-e31bd47b><div class="item" data-v-e31bd47b><div class="indicator" data-v-e31bd47b></div><a class="VPLink link link" href="/35.-che-di-li-jie-dui.html" data-v-e31bd47b><!--[--><p class="text" data-v-e31bd47b>35.彻底理解堆</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-e31bd47b data-v-e31bd47b><div class="item" data-v-e31bd47b><div class="indicator" data-v-e31bd47b></div><a class="VPLink link link" href="/36.-che-di-li-jie-lian-biao.html" data-v-e31bd47b><!--[--><p class="text" data-v-e31bd47b>36.彻底理解链表</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-e31bd47b data-v-e31bd47b><div class="item" data-v-e31bd47b><div class="indicator" data-v-e31bd47b></div><a class="VPLink link link" href="/37.-zhi-hu-hui-da.html" data-v-e31bd47b><!--[--><p class="text" data-v-e31bd47b>37.知乎回答</p><!--]--></a><!----></div><!----></div><!--]--></div></section></div><!--]--><!--[--><!--]--></nav></aside><div class="VPContent has-sidebar" id="VPContent" data-v-5a346dfe data-v-669faec9><div class="VPDoc has-sidebar has-aside" data-v-669faec9 data-v-6b87e69f><!--[--><!--]--><div class="container" data-v-6b87e69f><div class="aside" data-v-6b87e69f><div class="aside-curtain" data-v-6b87e69f></div><div class="aside-container" data-v-6b87e69f><div class="aside-content" data-v-6b87e69f><div class="VPDocAside" data-v-6b87e69f data-v-3f215769><!--[--><!--]--><!--[--><!--]--><div class="VPDocAsideOutline" role="navigation" data-v-3f215769 data-v-d330b1bb><div class="content" data-v-d330b1bb><div class="outline-marker" data-v-d330b1bb></div><div class="outline-title" role="heading" aria-level="2" data-v-d330b1bb>On this page</div><nav aria-labelledby="doc-outline-aria-label" data-v-d330b1bb><span class="visually-hidden" id="doc-outline-aria-label" data-v-d330b1bb> Table of Contents for current page </span><ul class="root" data-v-d330b1bb data-v-d0ee3533><!--[--><!--]--></ul></nav></div></div><!--[--><!--]--><div class="spacer" data-v-3f215769></div><!--[--><!--]--><!----><!--[--><!--]--><!--[--><!--]--></div></div></div></div><div class="content" data-v-6b87e69f><div class="content-container" data-v-6b87e69f><!--[--><!--]--><!----><main class="main" data-v-6b87e69f><div style="position:relative;" class="vp-doc _24_-che-di-li-jie-shu-de-di-gui-bian-li" data-v-6b87e69f><div><h1 id="_24-彻底理解树的递归遍历" tabindex="-1">24.彻底理解树的递归遍历 <a class="header-anchor" href="#_24-彻底理解树的递归遍历" aria-label="Permalink to &quot;24.彻底理解树的递归遍历&quot;">​</a></h1><p>如果把你丢到迷宫里该怎么找到出口呢？思考一下这个问题。 </p><p>很显然，像没头苍蝇一样乱冲乱撞对于走迷宫来说是没有用的，以最小代价找到迷宫的唯一出路就是<strong>系统性的将迷宫搜索一遍</strong>，所谓系统性指的是所有迷宫的路我们只走一遍而不重复，这是找到迷宫出口最高效的方法，千万不要将走迷宫寄希望于横冲直撞走大运的概率上。 </p><h2 id="什么是二叉树" tabindex="-1">什么是二叉树 <a class="header-anchor" href="#什么是二叉树" aria-label="Permalink to &quot;什么是二叉树&amp;#x20;&quot;">​</a></h2><p>在计算机科学中二叉树，binary tree，是一种数据结构，在该数据结构中每个节点最多有两个子节点，如图所示：</p><p><img src="/assets/24_1.eaf47576.jpg" alt=""></p><p>二叉树的定义就是这样简单，那么二叉树和迷宫有什么关系呢？ </p><p>本质上二叉树不过就是一个低配版的简单迷宫，因为每一岔口上最多就只有两条路。 </p><p>如果你能系统性的搜索迷宫那么你就应该明白如何遍历二叉树， </p><h2 id="如何遍历二叉树" tabindex="-1">如何遍历二叉树 <a class="header-anchor" href="#如何遍历二叉树" aria-label="Permalink to &quot;如何遍历二叉树&amp;#x20;&quot;">​</a></h2><p>想一下该如何系统性的搜索一个迷宫呢？显然，要想高效的搜索迷宫必须依赖<strong>搜索策略</strong>。 </p><p>这个策略实际上非常简单，对于每一条岔口都应用以下两条规则：</p><ol><li>对于每一个岔口，依次从左到右走一遍并记录下哪些路已经走过了 </li><li>如果当前的路已经是死胡同了或者当前岔口全部搜索完毕，那么我们应该原路返回上一个岔口</li></ol><p>由于本质上二叉树也是迷宫，因此就以二叉树为例讲解一下。 </p><p>由于二叉树最多有两个节点，也就是说二叉树这种迷宫每个岔口最多两条路，应用上述规则：</p><ol><li>对于每一个节点，先走左手边的路，左手边的路全部走完回到这个节点后继续右手边的路</li><li>如果当前是叶子节点或两条路都已搜索完毕则返回父节点</li></ol><p>接下来以上图中的二叉树为例来讲解一下该策略。 </p><p>迷宫入口就是节点1，如下图a所示，那么在节点1上我们遇到两条路，依据上述策略首先走左手边的路，这样来到了节点2，如下图b所示； </p><p>在节点2上我们还是面对两条路，依然使用上述策略我们来到了节点3，如下图c所示； </p><p>来到节点3后我们发现是一条死胡同，根据策略我们需要回退到来时的路，也就是回退到节点2，注意，这在计算机算法中被称为回溯，这是系统性搜索中常见的操作，如下图d所示。</p><p><img src="/assets/24_2.e64b21e5.jpg" alt=""></p><p>当回退到节点2后我们发现左手边的路都已经搜索过了，那么接下来我们可以放心的搜索2这个节点右手边的路了，这样我们来到了节点4，如下图e所示； </p><p>来到节点4后依然是死胡同，因此我们需要回退到节点2，图f；回退到节点2后我们发现两条路都已搜索完毕，那么我们可以放心的继续回退，这样我们又一次来到了节点1，如图g所示； </p><p>来到节点1后我们发现走手边的路已经全部搜索完毕，因此可以开始搜索1右手边的路了，这样我们来到了节点5，如图h所示；</p><p><img src="/assets/24_3.9f581414.jpg" alt=""></p><p>来到节点5后我们发现这里只有一条路，因此来到了节点6，如图i所示： </p><p>节点6同样是死胡同，因此回退到节点5，如图j所示； </p><p>回到节点5后我们发现所有的路都已搜索完毕，继续回退，这样我们就又来到了节点1，但这时，节点1左右子树全部遍历完毕，如图k所示；就这样我们遍历完了整个二叉树。</p><p><img src="/assets/24_4.49ec36fa.jpg" alt=""></p><p>有的同学看到这里可能会有疑问，那我们平时所说的先序遍历、中序遍历以及后续遍历指的是什么意思呢？ </p><p>实际上不管是先序、中序还是后续遍历都是上面的过程，不同点在于我们在什么时机下喊一声“到此一游”： </p><p>一到某个岔口就喊一声，这叫先序遍历； </p><p>搜索完左手边的路回退到岔口时喊一声，这叫中序遍历； </p><p>左右两条路都搜索完回退到岔口时喊一声，这叫后续遍历； </p><p>实际上<strong>这三种遍历方式本质上是一样的，区别仅仅在于处理节点的时机不同</strong>。 </p><p>值得注意的一旦是，彻底理解二叉树的遍历极其重要，这是解决几乎所有关于二叉树问题的基础。 </p><h2 id="递归实现二叉树的遍历" tabindex="-1">递归实现二叉树的遍历 <a class="header-anchor" href="#递归实现二叉树的遍历" aria-label="Permalink to &quot;递归实现二叉树的遍历&amp;#x20;&quot;">​</a></h2><p>在讲解递归遍历二叉树前我们首先用代码表示一下二叉树的结构：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">struct tree {</span></span>
<span class="line"><span style="color:#e1e4e8;"> struct tree* left;</span></span>
<span class="line"><span style="color:#e1e4e8;"> struct tree* right;</span></span>
<span class="line"><span style="color:#e1e4e8;"> int value;</span></span>
<span class="line"><span style="color:#e1e4e8;">};</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">struct tree {</span></span>
<span class="line"><span style="color:#24292e;"> struct tree* left;</span></span>
<span class="line"><span style="color:#24292e;"> struct tree* right;</span></span>
<span class="line"><span style="color:#24292e;"> int value;</span></span>
<span class="line"><span style="color:#24292e;">};</span></span></code></pre></div><p>从定义上我们可以看出树本身就是递归定义的，二叉树的左子树是二叉树(struct tree* left)，二叉树的右子树也是二叉树(struct tree* right)。假设给定一颗二叉树t，我们该如何遍历这颗二叉树呢？</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">struct tree* t; // 给定一颗二叉树</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">struct tree* t; // 给定一颗二叉树</span></span></code></pre></div><p>有的同学可能会觉得二叉树的遍历是一个非常复杂的过程，真的是这样的吗？ </p><p>假设我们已经实现了树的遍历函数，这个函数是这样定义的：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">void search_tree(struct tree* t);</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">void search_tree(struct tree* t);</span></span></code></pre></div><p>只要调用search_tree函数我们就能把一棵树的所有节点打印出来：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">struct tree* t; // 给定一颗二叉树</span></span>
<span class="line"><span style="color:#e1e4e8;">search_tree(t); // 打印二叉树所有节点</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">struct tree* t; // 给定一颗二叉树</span></span>
<span class="line"><span style="color:#24292e;">search_tree(t); // 打印二叉树所有节点</span></span></code></pre></div><p>要是真的有这样一个函数实际上我们的任务就完成了，如果我问你用这个函数把树t的左子树节点都打印出来该怎么写代码你肯定会觉得侮辱智商，很简单啊，不就是把树t的左子树传给search_tree这个函数吗？</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">seartch_tree(t-&gt;left); // 打印树t的左子树</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">seartch_tree(t-&gt;left); // 打印树t的左子树</span></span></code></pre></div><p>那么打印树t的右子树呢？同样easy啊</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">search_tree(t-&gt;right); // 打印树t的右子树</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">search_tree(t-&gt;right); // 打印树t的右子树</span></span></code></pre></div><p>是不是很简单，那么打印当前节点的值呢？你肯定已经懒得搭理我了 😃</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">printf(&quot;%d &quot;, t-&gt;value); // 打印根节点的值</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">printf(&quot;%d &quot;, t-&gt;value); // 打印根节点的值</span></span></code></pre></div><p>至此我们可以打印出根节点的值，也可以打印出树t的左子树节点，也可以打印出树t的右子树节点，<strong>如果我问你既然这些问题都解决了，那么该如何实现search_tree()这个函数</strong>？ </p><p>如果你不知道，那么就该我说这句话了：很简单啊有没有，不就是把上面几行代码写在一起嘛</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">void search_tree(struct tree* t) {</span></span>
<span class="line"><span style="color:#e1e4e8;">   printf(&quot;%d &quot;, t-&gt;value); // 打印根节点的值</span></span>
<span class="line"><span style="color:#e1e4e8;">   seartch_tree(t-&gt;left); // 打印树t的左子树</span></span>
<span class="line"><span style="color:#e1e4e8;">   search_tree(t-&gt;right); // 打印树t的右子树</span></span>
<span class="line"><span style="color:#e1e4e8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">void search_tree(struct tree* t) {</span></span>
<span class="line"><span style="color:#24292e;">   printf(&quot;%d &quot;, t-&gt;value); // 打印根节点的值</span></span>
<span class="line"><span style="color:#24292e;">   seartch_tree(t-&gt;left); // 打印树t的左子树</span></span>
<span class="line"><span style="color:#24292e;">   search_tree(t-&gt;right); // 打印树t的右子树</span></span>
<span class="line"><span style="color:#24292e;">}</span></span></code></pre></div><p>是不是很简单，是不是很easy，惊喜不惊喜，意外不意外，<strong>我们在仅仅只靠给出函数定义并凭借丰富想象的情况下就把这个函数给实现了</strong> 😃 </p><p>当然我们需要对特殊情况进行处理，如果给定的一棵树为空，那么直接返回，最终代码就是：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">void search_tree(struct tree* t) {</span></span>
<span class="line"><span style="color:#e1e4e8;"> if (t == NULL） // 如果是一颗空树则直接返回</span></span>
<span class="line"><span style="color:#e1e4e8;"> return;</span></span>
<span class="line"><span style="color:#e1e4e8;"> printf(&quot;%d &quot;, t-&gt;value); // 打印根节点的值</span></span>
<span class="line"><span style="color:#e1e4e8;"> seartch_tree(t-&gt;left); // 打印树t的左子树</span></span>
<span class="line"><span style="color:#e1e4e8;"> search_tree(t-&gt;right); // 打印树t的右子树</span></span>
<span class="line"><span style="color:#e1e4e8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">void search_tree(struct tree* t) {</span></span>
<span class="line"><span style="color:#24292e;"> if (t == NULL） // 如果是一颗空树则直接返回</span></span>
<span class="line"><span style="color:#24292e;"> return;</span></span>
<span class="line"><span style="color:#24292e;"> printf(&quot;%d &quot;, t-&gt;value); // 打印根节点的值</span></span>
<span class="line"><span style="color:#24292e;"> seartch_tree(t-&gt;left); // 打印树t的左子树</span></span>
<span class="line"><span style="color:#24292e;"> search_tree(t-&gt;right); // 打印树t的右子树</span></span>
<span class="line"><span style="color:#24292e;">}</span></span></code></pre></div><p>有的同学可能会一脸懵逼，这个函数就这样实现了？正确吗，不用怀疑，这段代码无比正确，你可以自己构造一棵树并试着运行一下这段代码。 </p><p>上述代码就是树的<strong>递归遍历</strong>。 </p><p>我知道这些一脸懵逼的同学心里的怎么想的，这段代码看上去确实正确，运行起来也正确，那么这段代码的运行过程是什么样的呢？ </p><h2 id="递归调用过程" tabindex="-1">递归调用过程 <a class="header-anchor" href="#递归调用过程" aria-label="Permalink to &quot;递归调用过程&amp;#x20;&quot;">​</a></h2><p>假设有这样一段代码：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">void C() {</span></span>
<span class="line"><span style="color:#e1e4e8;">}</span></span>
<span class="line"><span style="color:#e1e4e8;">void B() {</span></span>
<span class="line"><span style="color:#e1e4e8;"> C();</span></span>
<span class="line"><span style="color:#e1e4e8;">}</span></span>
<span class="line"><span style="color:#e1e4e8;">void A() {</span></span>
<span class="line"><span style="color:#e1e4e8;"> B();</span></span>
<span class="line"><span style="color:#e1e4e8;">}</span></span>
<span class="line"><span style="color:#e1e4e8;">void main() {</span></span>
<span class="line"><span style="color:#e1e4e8;"> A();</span></span>
<span class="line"><span style="color:#e1e4e8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">void C() {</span></span>
<span class="line"><span style="color:#24292e;">}</span></span>
<span class="line"><span style="color:#24292e;">void B() {</span></span>
<span class="line"><span style="color:#24292e;"> C();</span></span>
<span class="line"><span style="color:#24292e;">}</span></span>
<span class="line"><span style="color:#24292e;">void A() {</span></span>
<span class="line"><span style="color:#24292e;"> B();</span></span>
<span class="line"><span style="color:#24292e;">}</span></span>
<span class="line"><span style="color:#24292e;">void main() {</span></span>
<span class="line"><span style="color:#24292e;"> A();</span></span>
<span class="line"><span style="color:#24292e;">}</span></span></code></pre></div><p>A()会调用B()，B()会调用C()，那么函数调用过程如图所示：</p><p><img src="/assets/24_5.81292b8f.jpg" alt=""></p><p>实际上每一个函数被调用时都有对应的一段内存，这段内存中保存了调用该函数时传入的<strong>参数以及函数中定义的局部变量</strong>，这段内存被称为<strong>函数帧</strong>，函数的调用过程具有数据结构中栈的性质，也就是<strong>先进后出</strong>，比如当函数C()执行完毕后该函数对应的函数帧释放并回到函数B，函数B执行完毕后对应的函数帧被释放并回到函数A。 </p><p>有了上述知识我们就可以看一下树的递归调用函数是如何执行的了。为简单起见，我们给定一颗比较简单的树：</p><p><img src="/assets/24_6.f55b4a96.jpg" alt=""></p><p>当在该树上调用search_tree函数时整个递归调用过程是怎样的呢，如图所示：</p><p><img src="/assets/24_7.960c1517.jpg" alt=""></p><p>首先在根节点1上调用search_tree()，当打印完当前节点的值后在1的左子树节点上调用search_tree，这时第二个函数帧入栈；打印完当前节点的值(2)后在2的左子树上调用search_tree，这样第三个函数帧入栈；同样是打印完当前节点的值后(3)在3的左子树上调用search_tree，第四个函数帧入栈；由于3的左子树为空，因此第四个函数帧执行第一句时就会退出，因此我们又来到了第三个函数帧，此时节点3的左子树遍历完毕，因此开始在3的右子树节点上调用search_tree，接下来的过程如图所示：</p><p><img src="/assets/24_8.8f360339.jpg" alt=""></p><p>这个过程会一直持续直到节点1的右子树也遍历完毕后整个递归调用过程运行完毕。注意，函数帧中实际上不会包含代码，这里为方便观察search_tree的递归调用过程才加上去的。上图中没有将整个调用过程全部展示出来，大家可以自行推导节点5和节点6是如何遍历的。 </p><p>从这个过程中我们可以看到，函数的递归调用其实没什么神秘的，和普通函数调用其实是一样的，只不过递归函数的特殊之处在于调用的不是其它函数而是本身。 </p><p>从上面的函数调用过程可以得出一个重要的结论，那就是<strong>递归函数不会一直调用下去</strong>，否则就是栈溢出了，即著名的Stack Overflow，那么递归函数调用栈在什么情况下就不再增长了呢，在这个例子中就是当给定的树已经为空时递归函数调用栈将不再增长，因此对于递归函数我们必须指明在什么情况下递归函数将直接返回，也就是常说的递归函数的出口。</p><h2 id="递归实现树的三种遍历方法" tabindex="-1">递归实现树的三种遍历方法 <a class="header-anchor" href="#递归实现树的三种遍历方法" aria-label="Permalink to &quot;递归实现树的三种遍历方法&amp;#x20;&quot;">​</a></h2><p>到目前为止，我们已经知道了该如何遍历树、如何用代码实现以及代码的调用过程，注意打印语句的位置：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">printf(&quot;%d &quot;, t-&gt;value); // 打印根节点的值</span></span>
<span class="line"><span style="color:#e1e4e8;">seartch_tree(t-&gt;left); // 打印树t的左子树</span></span>
<span class="line"><span style="color:#e1e4e8;">search_tree(t-&gt;right); // 打印树t的右子树</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">printf(&quot;%d &quot;, t-&gt;value); // 打印根节点的值</span></span>
<span class="line"><span style="color:#24292e;">seartch_tree(t-&gt;left); // 打印树t的左子树</span></span>
<span class="line"><span style="color:#24292e;">search_tree(t-&gt;right); // 打印树t的右子树</span></span></code></pre></div><p>中序和后序遍历都可以很容易的用递归遍历方法来实现，如下为中序遍历：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">void search_in_order(struct tree* t) {</span></span>
<span class="line"><span style="color:#e1e4e8;">   if (t == NULL） // 如果是一颗空树则直接返回</span></span>
<span class="line"><span style="color:#e1e4e8;">     return;</span></span>
<span class="line"><span style="color:#e1e4e8;">      </span></span>
<span class="line"><span style="color:#e1e4e8;">   search_in_order(t-&gt;left); // 打印树t的左子树</span></span>
<span class="line"><span style="color:#e1e4e8;">   printf(&quot;%d &quot;, t-&gt;value); // 打印根节点的值</span></span>
<span class="line"><span style="color:#e1e4e8;">   search_in_order(t-&gt;right); // 打印树t的右子树</span></span>
<span class="line"><span style="color:#e1e4e8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">void search_in_order(struct tree* t) {</span></span>
<span class="line"><span style="color:#24292e;">   if (t == NULL） // 如果是一颗空树则直接返回</span></span>
<span class="line"><span style="color:#24292e;">     return;</span></span>
<span class="line"><span style="color:#24292e;">      </span></span>
<span class="line"><span style="color:#24292e;">   search_in_order(t-&gt;left); // 打印树t的左子树</span></span>
<span class="line"><span style="color:#24292e;">   printf(&quot;%d &quot;, t-&gt;value); // 打印根节点的值</span></span>
<span class="line"><span style="color:#24292e;">   search_in_order(t-&gt;right); // 打印树t的右子树</span></span>
<span class="line"><span style="color:#24292e;">}</span></span></code></pre></div><p>后序遍历则为：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">void search_post_order(struct tree* t) {</span></span>
<span class="line"><span style="color:#e1e4e8;">   if (t == NULL） // 如果是一颗空树则直接返回</span></span>
<span class="line"><span style="color:#e1e4e8;">     return;</span></span>
<span class="line"><span style="color:#e1e4e8;">      </span></span>
<span class="line"><span style="color:#e1e4e8;">   search_in_order(t-&gt;left); // 打印树t的左子树</span></span>
<span class="line"><span style="color:#e1e4e8;">   search_in_order(t-&gt;right); // 打印树t的右子树</span></span>
<span class="line"><span style="color:#e1e4e8;">   printf(&quot;%d &quot;, t-&gt;value); // 打印根节点的值</span></span>
<span class="line"><span style="color:#e1e4e8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">void search_post_order(struct tree* t) {</span></span>
<span class="line"><span style="color:#24292e;">   if (t == NULL） // 如果是一颗空树则直接返回</span></span>
<span class="line"><span style="color:#24292e;">     return;</span></span>
<span class="line"><span style="color:#24292e;">      </span></span>
<span class="line"><span style="color:#24292e;">   search_in_order(t-&gt;left); // 打印树t的左子树</span></span>
<span class="line"><span style="color:#24292e;">   search_in_order(t-&gt;right); // 打印树t的右子树</span></span>
<span class="line"><span style="color:#24292e;">   printf(&quot;%d &quot;, t-&gt;value); // 打印根节点的值</span></span>
<span class="line"><span style="color:#24292e;">}</span></span></code></pre></div><p>至此，有的同学可能会觉得树的遍历简直是太简单了，那么如果让你用非递归的方式来实现树的遍历你该怎么实现呢？ </p><p><em><strong>在阅读下面的内容之前请确保你已经真正理解了前几节的内容</strong></em>。 </p><p>如果你还是不能彻底理解请再多仔细阅读几遍。</p><h2 id="如何将递归转为非递归" tabindex="-1">如何将递归转为非递归 <a class="header-anchor" href="#如何将递归转为非递归" aria-label="Permalink to &quot;如何将递归转为非递归&quot;">​</a></h2><p>虽然递归实现简单，但是递归函数有自己特定的问题，比如递归调用会耗费很多的栈空间，也就是内存；同时该过程也较为耗时，因此其性能通常不及非递归版本。 </p><p>那么我们该如何实现非递归的遍历树呢？ </p><p>要解决这个问题，我们必须清楚的理解递归函数的调用过程。 </p><p>从递归函数的调用过程可以看出，<strong>递归调用无非就是函数帧入栈出栈的过程</strong>，因此我们可以直接使用栈来模拟这个过程，只不过栈中保存的不是函数的运行状态而是树节点。 </p><p>确定用栈来模拟递归调用这一点后，接下来我们就必须明确两件事：</p><ol><li>什么情况下入栈 </li><li>什么情况下出栈</li></ol><p>我们还是以先序遍历为例来说明。 </p><p>仔细观察递归调用的过程，我们会发现这样的规律：</p><ol><li>不管三七二十一先把从根节点开始的所有左子树节点放入栈中 </li><li>查看栈顶元素，如果栈顶元素有右子树那么右子树入栈并以右子树为新的起点并重复过程1直到栈空为止</li></ol><p>现在我们可以回答这两个问题了。 </p><p>什么情况下入栈？ </p><p>最开始时先把从根节点开始的所有左子树节点放入栈中，第二步中如果栈顶有右子树那么重复过程 1，这两种情况下会入栈。 </p><p>那么什么情况下出栈呢？ </p><p>当查看栈顶元素时实际上我们就可以直接pop掉栈顶元素了，这是和递归调用不同的一点，为什么呢？因为查看栈顶节点时我们可以确定一点事，那就是当前节点的左子树一定已经处理完毕了，因此对于栈顶元素来说我们需要的仅仅是其右子树的信息，拿到右子树信息后栈顶节点就可以pop掉了。 </p><p>因此上面的描述用代码来表示就是：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">void search(tree* root) {</span></span>
<span class="line"><span style="color:#e1e4e8;"> if(root == NULL)</span></span>
<span class="line"><span style="color:#e1e4e8;"> return ;</span></span>
<span class="line"><span style="color:#e1e4e8;"> stack&lt;tree*&gt;s;</span></span>
<span class="line"><span style="color:#e1e4e8;"> // 不管三七二十一先把从根节点开始的所有左子树节点放入栈中</span></span>
<span class="line"><span style="color:#e1e4e8;"> while(root){</span></span>
<span class="line"><span style="color:#e1e4e8;">  s.push(root);</span></span>
<span class="line"><span style="color:#e1e4e8;">  root=root-&gt;left;</span></span>
<span class="line"><span style="color:#e1e4e8;"> }</span></span>
<span class="line"><span style="color:#e1e4e8;"> while(!s.empty()){</span></span>
<span class="line"><span style="color:#e1e4e8;">  // 查看栈顶元素，如果栈顶元素有右子树那么右子树入栈并重复过程1直到栈空为止</span></span>
<span class="line"><span style="color:#e1e4e8;">  tree* top = s.top();</span></span>
<span class="line"><span style="color:#e1e4e8;">  tree* t = top-&gt;right;</span></span>
<span class="line"><span style="color:#e1e4e8;">  s.pop();</span></span>
<span class="line"><span style="color:#e1e4e8;">  while(t){</span></span>
<span class="line"><span style="color:#e1e4e8;">   s.push(t);</span></span>
<span class="line"><span style="color:#e1e4e8;">   t = t-&gt;left;</span></span>
<span class="line"><span style="color:#e1e4e8;">  }</span></span>
<span class="line"><span style="color:#e1e4e8;"> }</span></span>
<span class="line"><span style="color:#e1e4e8;"> return r;</span></span>
<span class="line"><span style="color:#e1e4e8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">void search(tree* root) {</span></span>
<span class="line"><span style="color:#24292e;"> if(root == NULL)</span></span>
<span class="line"><span style="color:#24292e;"> return ;</span></span>
<span class="line"><span style="color:#24292e;"> stack&lt;tree*&gt;s;</span></span>
<span class="line"><span style="color:#24292e;"> // 不管三七二十一先把从根节点开始的所有左子树节点放入栈中</span></span>
<span class="line"><span style="color:#24292e;"> while(root){</span></span>
<span class="line"><span style="color:#24292e;">  s.push(root);</span></span>
<span class="line"><span style="color:#24292e;">  root=root-&gt;left;</span></span>
<span class="line"><span style="color:#24292e;"> }</span></span>
<span class="line"><span style="color:#24292e;"> while(!s.empty()){</span></span>
<span class="line"><span style="color:#24292e;">  // 查看栈顶元素，如果栈顶元素有右子树那么右子树入栈并重复过程1直到栈空为止</span></span>
<span class="line"><span style="color:#24292e;">  tree* top = s.top();</span></span>
<span class="line"><span style="color:#24292e;">  tree* t = top-&gt;right;</span></span>
<span class="line"><span style="color:#24292e;">  s.pop();</span></span>
<span class="line"><span style="color:#24292e;">  while(t){</span></span>
<span class="line"><span style="color:#24292e;">   s.push(t);</span></span>
<span class="line"><span style="color:#24292e;">   t = t-&gt;left;</span></span>
<span class="line"><span style="color:#24292e;">  }</span></span>
<span class="line"><span style="color:#24292e;"> }</span></span>
<span class="line"><span style="color:#24292e;"> return r;</span></span>
<span class="line"><span style="color:#24292e;">}</span></span></code></pre></div><p>上述代码是实现树的三种非递归遍历的基础，请务必理解。 </p><p>接下来就可以实现树的三种非递归遍历了。</p><h2 id="非递归遍历" tabindex="-1">非递归遍历 <a class="header-anchor" href="#非递归遍历" aria-label="Permalink to &quot;非递归遍历&amp;#x20;&quot;">​</a></h2><p>有的同学可能已经注意到了，上一节中的代码中没有printf语句，如果让你利用上面的代码以先序遍历方式打印节点该怎么实现呢？如果你真的已经理解了上述代码那么就非常简单了，对于先序遍历来说，我们只需要在<strong>节点入栈</strong>之前打印出来就可以了：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">void search_pre_order(tree* root) {</span></span>
<span class="line"><span style="color:#e1e4e8;"> if(root == NULL)</span></span>
<span class="line"><span style="color:#e1e4e8;"> return ;</span></span>
<span class="line"><span style="color:#e1e4e8;"> stack&lt;tree*&gt;s;</span></span>
<span class="line"><span style="color:#e1e4e8;"> // 不管三七二十一先把从根节点开始的所有左子树节点放入栈中</span></span>
<span class="line"><span style="color:#e1e4e8;"> while(root){</span></span>
<span class="line"><span style="color:#e1e4e8;">  printf(&quot;%d &quot;, root-&gt;value); // 节点入栈前打印</span></span>
<span class="line"><span style="color:#e1e4e8;">  s.push(root);</span></span>
<span class="line"><span style="color:#e1e4e8;">  root=root-&gt;left;</span></span>
<span class="line"><span style="color:#e1e4e8;"> }</span></span>
<span class="line"><span style="color:#e1e4e8;"> while(!s.empty()){</span></span>
<span class="line"><span style="color:#e1e4e8;">  // 查看栈顶元素，如果栈顶元素有右子树那么右子树入栈并重复过程1直到栈空为止</span></span>
<span class="line"><span style="color:#e1e4e8;">  tree* top = s.top();</span></span>
<span class="line"><span style="color:#e1e4e8;">  tree* t = top-&gt;right;</span></span>
<span class="line"><span style="color:#e1e4e8;">  s.pop();</span></span>
<span class="line"><span style="color:#e1e4e8;">  while(t){</span></span>
<span class="line"><span style="color:#e1e4e8;">   printf(&quot;%d &quot;, root-&gt;value); // 节点入栈前打印</span></span>
<span class="line"><span style="color:#e1e4e8;">   s.push(t);</span></span>
<span class="line"><span style="color:#e1e4e8;">   t = t-&gt;left;</span></span>
<span class="line"><span style="color:#e1e4e8;">  }</span></span>
<span class="line"><span style="color:#e1e4e8;"> }</span></span>
<span class="line"><span style="color:#e1e4e8;"> return r;</span></span>
<span class="line"><span style="color:#e1e4e8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">void search_pre_order(tree* root) {</span></span>
<span class="line"><span style="color:#24292e;"> if(root == NULL)</span></span>
<span class="line"><span style="color:#24292e;"> return ;</span></span>
<span class="line"><span style="color:#24292e;"> stack&lt;tree*&gt;s;</span></span>
<span class="line"><span style="color:#24292e;"> // 不管三七二十一先把从根节点开始的所有左子树节点放入栈中</span></span>
<span class="line"><span style="color:#24292e;"> while(root){</span></span>
<span class="line"><span style="color:#24292e;">  printf(&quot;%d &quot;, root-&gt;value); // 节点入栈前打印</span></span>
<span class="line"><span style="color:#24292e;">  s.push(root);</span></span>
<span class="line"><span style="color:#24292e;">  root=root-&gt;left;</span></span>
<span class="line"><span style="color:#24292e;"> }</span></span>
<span class="line"><span style="color:#24292e;"> while(!s.empty()){</span></span>
<span class="line"><span style="color:#24292e;">  // 查看栈顶元素，如果栈顶元素有右子树那么右子树入栈并重复过程1直到栈空为止</span></span>
<span class="line"><span style="color:#24292e;">  tree* top = s.top();</span></span>
<span class="line"><span style="color:#24292e;">  tree* t = top-&gt;right;</span></span>
<span class="line"><span style="color:#24292e;">  s.pop();</span></span>
<span class="line"><span style="color:#24292e;">  while(t){</span></span>
<span class="line"><span style="color:#24292e;">   printf(&quot;%d &quot;, root-&gt;value); // 节点入栈前打印</span></span>
<span class="line"><span style="color:#24292e;">   s.push(t);</span></span>
<span class="line"><span style="color:#24292e;">   t = t-&gt;left;</span></span>
<span class="line"><span style="color:#24292e;">  }</span></span>
<span class="line"><span style="color:#24292e;"> }</span></span>
<span class="line"><span style="color:#24292e;"> return r;</span></span>
<span class="line"><span style="color:#24292e;">}</span></span></code></pre></div><p>那么对于中序遍历呢？实际上也非常简单，我们只需要在<strong>节点pop</strong>时打印就可以了：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">void search_in_order(tree* root) {</span></span>
<span class="line"><span style="color:#e1e4e8;"> if(root == NULL)</span></span>
<span class="line"><span style="color:#e1e4e8;"> return ;</span></span>
<span class="line"><span style="color:#e1e4e8;"> stack&lt;tree*&gt;s;</span></span>
<span class="line"><span style="color:#e1e4e8;"> // 不管三七二十一先把从根节点开始的所有左子树节点放入栈中</span></span>
<span class="line"><span style="color:#e1e4e8;"> while(root){</span></span>
<span class="line"><span style="color:#e1e4e8;">  s.push(root);</span></span>
<span class="line"><span style="color:#e1e4e8;">  root=root-&gt;left;</span></span>
<span class="line"><span style="color:#e1e4e8;"> }</span></span>
<span class="line"><span style="color:#e1e4e8;"> while(!s.empty()){</span></span>
<span class="line"><span style="color:#e1e4e8;">  // 查看栈顶元素，如果栈顶元素有右子树那么右子树入栈并重复过程1直到栈空为止</span></span>
<span class="line"><span style="color:#e1e4e8;">  tree* top = s.top();</span></span>
<span class="line"><span style="color:#e1e4e8;">  printf(&quot;%d &quot;, top-&gt;value); // 节点pop时打印</span></span>
<span class="line"><span style="color:#e1e4e8;">  tree* t = top-&gt;right;</span></span>
<span class="line"><span style="color:#e1e4e8;">  s.pop();</span></span>
<span class="line"><span style="color:#e1e4e8;">  while(t){</span></span>
<span class="line"><span style="color:#e1e4e8;">   s.push(t);</span></span>
<span class="line"><span style="color:#e1e4e8;">   t = t-&gt;left;</span></span>
<span class="line"><span style="color:#e1e4e8;">  }</span></span>
<span class="line"><span style="color:#e1e4e8;"> }</span></span>
<span class="line"><span style="color:#e1e4e8;"> return r;</span></span>
<span class="line"><span style="color:#e1e4e8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">void search_in_order(tree* root) {</span></span>
<span class="line"><span style="color:#24292e;"> if(root == NULL)</span></span>
<span class="line"><span style="color:#24292e;"> return ;</span></span>
<span class="line"><span style="color:#24292e;"> stack&lt;tree*&gt;s;</span></span>
<span class="line"><span style="color:#24292e;"> // 不管三七二十一先把从根节点开始的所有左子树节点放入栈中</span></span>
<span class="line"><span style="color:#24292e;"> while(root){</span></span>
<span class="line"><span style="color:#24292e;">  s.push(root);</span></span>
<span class="line"><span style="color:#24292e;">  root=root-&gt;left;</span></span>
<span class="line"><span style="color:#24292e;"> }</span></span>
<span class="line"><span style="color:#24292e;"> while(!s.empty()){</span></span>
<span class="line"><span style="color:#24292e;">  // 查看栈顶元素，如果栈顶元素有右子树那么右子树入栈并重复过程1直到栈空为止</span></span>
<span class="line"><span style="color:#24292e;">  tree* top = s.top();</span></span>
<span class="line"><span style="color:#24292e;">  printf(&quot;%d &quot;, top-&gt;value); // 节点pop时打印</span></span>
<span class="line"><span style="color:#24292e;">  tree* t = top-&gt;right;</span></span>
<span class="line"><span style="color:#24292e;">  s.pop();</span></span>
<span class="line"><span style="color:#24292e;">  while(t){</span></span>
<span class="line"><span style="color:#24292e;">   s.push(t);</span></span>
<span class="line"><span style="color:#24292e;">   t = t-&gt;left;</span></span>
<span class="line"><span style="color:#24292e;">  }</span></span>
<span class="line"><span style="color:#24292e;"> }</span></span>
<span class="line"><span style="color:#24292e;"> return r;</span></span>
<span class="line"><span style="color:#24292e;">}</span></span></code></pre></div><p>对于后续遍历呢？ </p><p>后续遍历相对复杂，原因就在于出栈的情况不一样了。 </p><p>在先序和中序遍历过程中，只要左子树处理完毕实际上栈顶元素就可以出栈了，但是后续遍历情况不同，什么是后续遍历？只有左子树和右子树都遍历完毕才可以处理当前节点，这是后续遍历，那么我们该如何知道当前节点的左子树和右子树都处理完了呢？</p><p>显然我们需要某种方法记录下遍历的过程，实际上我们只需要记录下遍历的前一个节点就足够了。 </p><p>如果我们知道了遍历过程中的前一个节点，那么我们就可以做如下判断了：</p><ol><li>如果前一个节点是当前节点的右子树，那么说明右子树遍历完毕可以pop了 </li><li>如果前一个节点是当前节点的左子树而且当前节点右子树为空，那么说明可以pop了 </li><li>如果当前节点的左子树和右子树都为空，也就是叶子节点那么说明可以pop了 </li></ol><p>这样什么情况下出栈的问题就解决了，如果不符合这些情况就不能出栈。 </p><p>只需要根据以上分析对代码稍加修改就可以了：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">void search_post_order(tree* root) {</span></span>
<span class="line"><span style="color:#e1e4e8;"> if(root == NULL)</span></span>
<span class="line"><span style="color:#e1e4e8;"> return ;</span></span>
<span class="line"><span style="color:#e1e4e8;"> stack&lt;tree*&gt;s;</span></span>
<span class="line"><span style="color:#e1e4e8;"> TreeNode* last=NULL; // 记录遍历的前一个节点</span></span>
<span class="line"><span style="color:#e1e4e8;"> // 不管三七二十一先把从根节点开始的所有左子树节点放入栈中</span></span>
<span class="line"><span style="color:#e1e4e8;"> while(root){</span></span>
<span class="line"><span style="color:#e1e4e8;">  s.push(root);</span></span>
<span class="line"><span style="color:#e1e4e8;">  root=root-&gt;left;</span></span>
<span class="line"><span style="color:#e1e4e8;"> }</span></span>
<span class="line"><span style="color:#e1e4e8;"> while(!s.empty()){</span></span>
<span class="line"><span style="color:#e1e4e8;">  tree* top = s.top();</span></span>
<span class="line"><span style="color:#e1e4e8;">  if (top-&gt;left ==NULL &amp;&amp; top-&gt;right == NULL || // 当前节点为叶子节点</span></span>
<span class="line"><span style="color:#e1e4e8;">  last==top-&gt;right || // 前一个节点为当前节点的右子树</span></span>
<span class="line"><span style="color:#e1e4e8;">  top-&gt;right==NULL &amp;&amp; last==top-&gt;left){ // 前一个节点为当前节点左子树且右子树为空</span></span>
<span class="line"><span style="color:#e1e4e8;">   printf(&quot;%d &quot;, top-&gt;value); // 节点pop时打印</span></span>
<span class="line"><span style="color:#e1e4e8;">   last = top; // 记录下前一个节点</span></span>
<span class="line"><span style="color:#e1e4e8;">   s.pop();</span></span>
<span class="line"><span style="color:#e1e4e8;">  } else {</span></span>
<span class="line"><span style="color:#e1e4e8;">   tree* t = top-&gt;right;</span></span>
<span class="line"><span style="color:#e1e4e8;">   while(t){</span></span>
<span class="line"><span style="color:#e1e4e8;">    s.push(t);</span></span>
<span class="line"><span style="color:#e1e4e8;">    t = t-&gt;left;</span></span>
<span class="line"><span style="color:#e1e4e8;">   }</span></span>
<span class="line"><span style="color:#e1e4e8;">  }</span></span>
<span class="line"><span style="color:#e1e4e8;"> }</span></span>
<span class="line"><span style="color:#e1e4e8;"> return r;</span></span>
<span class="line"><span style="color:#e1e4e8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">void search_post_order(tree* root) {</span></span>
<span class="line"><span style="color:#24292e;"> if(root == NULL)</span></span>
<span class="line"><span style="color:#24292e;"> return ;</span></span>
<span class="line"><span style="color:#24292e;"> stack&lt;tree*&gt;s;</span></span>
<span class="line"><span style="color:#24292e;"> TreeNode* last=NULL; // 记录遍历的前一个节点</span></span>
<span class="line"><span style="color:#24292e;"> // 不管三七二十一先把从根节点开始的所有左子树节点放入栈中</span></span>
<span class="line"><span style="color:#24292e;"> while(root){</span></span>
<span class="line"><span style="color:#24292e;">  s.push(root);</span></span>
<span class="line"><span style="color:#24292e;">  root=root-&gt;left;</span></span>
<span class="line"><span style="color:#24292e;"> }</span></span>
<span class="line"><span style="color:#24292e;"> while(!s.empty()){</span></span>
<span class="line"><span style="color:#24292e;">  tree* top = s.top();</span></span>
<span class="line"><span style="color:#24292e;">  if (top-&gt;left ==NULL &amp;&amp; top-&gt;right == NULL || // 当前节点为叶子节点</span></span>
<span class="line"><span style="color:#24292e;">  last==top-&gt;right || // 前一个节点为当前节点的右子树</span></span>
<span class="line"><span style="color:#24292e;">  top-&gt;right==NULL &amp;&amp; last==top-&gt;left){ // 前一个节点为当前节点左子树且右子树为空</span></span>
<span class="line"><span style="color:#24292e;">   printf(&quot;%d &quot;, top-&gt;value); // 节点pop时打印</span></span>
<span class="line"><span style="color:#24292e;">   last = top; // 记录下前一个节点</span></span>
<span class="line"><span style="color:#24292e;">   s.pop();</span></span>
<span class="line"><span style="color:#24292e;">  } else {</span></span>
<span class="line"><span style="color:#24292e;">   tree* t = top-&gt;right;</span></span>
<span class="line"><span style="color:#24292e;">   while(t){</span></span>
<span class="line"><span style="color:#24292e;">    s.push(t);</span></span>
<span class="line"><span style="color:#24292e;">    t = t-&gt;left;</span></span>
<span class="line"><span style="color:#24292e;">   }</span></span>
<span class="line"><span style="color:#24292e;">  }</span></span>
<span class="line"><span style="color:#24292e;"> }</span></span>
<span class="line"><span style="color:#24292e;"> return r;</span></span>
<span class="line"><span style="color:#24292e;">}</span></span></code></pre></div><h2 id="总结" tabindex="-1">总结 <a class="header-anchor" href="#总结" aria-label="Permalink to &quot;总结&amp;#x20;&quot;">​</a></h2><p>树的递归遍历相对简单且容易理解，但是递归调用实际上隐藏了相对复杂的遍历过程，要想以非递归的方式来遍历二叉树就需要仔细理解递归调用过程。</p></div></div></main><footer class="VPDocFooter" data-v-6b87e69f data-v-ef5dee53><!--[--><!--]--><!----><nav class="prev-next" data-v-ef5dee53><div class="pager" data-v-ef5dee53><!----></div><div class="pager" data-v-ef5dee53><a class="pager-link next" href="/1.-ni-guan-zhe-po-wan-yi-jiao-cpu.html" data-v-ef5dee53><span class="desc" data-v-ef5dee53>Next page</span><span class="title" data-v-ef5dee53>1.你管这破玩意叫CPU？</span></a></div></nav></footer><!--[--><!--]--></div></div></div><!--[--><!--]--></div></div><!----><!--[--><!--]--></div></div>
    <script>window.__VP_HASH_MAP__=JSON.parse("{\"19.cpu-jin-hua-lun-jing-jian-zhi-ling-ji-de-dan-sheng.md\":\"5ed86747\",\"32.-cheng-xu-yuan-ying-ru-he-li-jie-tou-wen-jian.md\":\"d27d7279\",\"13.-xian-cheng-an-quan-dai-ma-dao-di-shi-zen-mo-bian-xie-de.md\":\"7be00a7e\",\"33.-cheng-xu-yuan-ying-ru-he-li-jie-duo-tai.md\":\"14a3d52e\",\"34.-wei-shi-mo-chou-xiang-zai-ji-suan-ji-ke-xue-zhong-ru-ci-zhong-yao.md\":\"bc5c97bc\",\"readme.md\":\"f201b8ce\",\"summary.md\":\"d80c65e0\",\"api-examples.md\":\"3c175b17\",\"index.md\":\"de92dc13\",\"markdown-examples.md\":\"2066c371\",\"3.-zhi-hang-io-cao-zuo-shi-di-ceng-fa-sheng-le-shi-mo.md\":\"e47816df\",\"24.-che-di-li-jie-shu-de-di-gui-bian-li.md\":\"16408148\",\"2.-ni-guan-zhe-po-wan-yi-jiao-xian-cheng.md\":\"b2464c4a\",\"28.-cheng-xu-yuan-huan-xu-yao-li-jie-hui-bian-ma.md\":\"d8de9fd3\",\"29.-shi-mo-shi-yi-bu-bian-cheng.md\":\"9a1504b8\",\"1.-ni-guan-zhe-po-wan-yi-jiao-cpu.md\":\"d18abf37\",\"10.-che-di-li-jie-hui-tiao-han-shu.md\":\"41dca60d\",\"17.cpu-yu-fen-zhi-yu-ce.md\":\"603da23e\",\"27.-hui-tiao-han-shu-shi-xian-de-yuan-li-shi-shi-mo.md\":\"d6c95f34\",\"26.cpu-ke-yi-pao-duo-kuai-cong-di-qiu-dao-huo-xing-de-ju-li-gao-su-ni.md\":\"7cd1e1a2\",\"6.cpu-shi-ru-he-li-jie-01-er-jin-zhi-de.md\":\"e06c0870\",\"16.cpu-shi-ru-he-du-xie-nei-cun-de.md\":\"a7481c84\",\"36.-che-di-li-jie-lian-biao.md\":\"a9b10f09\",\"14.-cheng-xu-yuan-ying-ru-he-li-jie-xie-cheng.md\":\"0f208b45\",\"9.-han-shu-yun-hang-shi-zai-nei-cun-zhong-shi-shi-mo-yang-zi.md\":\"75a9bead\",\"31.-cheng-xu-yuan-ying-ru-he-li-jie-biao-zhun-ku.md\":\"673628e8\",\"20.cpu-he-shu-yu-xian-cheng-shu-you-shi-mo-guan-xi.md\":\"4b37b2d5\",\"21.-ni-guan-zhe-po-wan-yi-jiao-mmap.md\":\"f5f1cbba\",\"8.-bian-yi-qi-shi-ru-he-gong-zuo-de.md\":\"ba41e706\",\"18.cpu-jin-hua-lun-fu-za-zhi-ling-ji-de-dan-sheng.md\":\"c0d41fa7\",\"30.-che-di-li-jiecyu-yan-zhong-de-zhi-zhen.md\":\"da29961e\",\"4.-cong-xiao-bai-dao-gao-shou-ni-xu-yao-li-jie-tong-bu-yu-yi-bu.md\":\"2fc168dc\",\"37.-zhi-hu-hui-da.md\":\"8f8d3d70\",\"11.-zi-ji-dong-shou-shi-xian-malloc-nei-cun-fen-pei-qi.md\":\"650ce069\",\"23.-cao-zuo-xi-tong-yu-nei-he-you-shi-mo-qu-bie.md\":\"8f1c495f\",\"15.-shi-ge-nei-cun-yin-fa-de-da-keng.md\":\"94c13caa\",\"35.-che-di-li-jie-dui.md\":\"36d4d481\",\"22.-che-di-li-jie-ling-kao-bei.md\":\"8c875800\",\"12.-xian-cheng-chi-shi-ru-he-shi-xian-de.md\":\"4644c250\",\"5.-ni-guan-zhe-po-wan-yi-jiao-io-duo-lu-fu-yong.md\":\"afc52ab1\",\"7.cpu-kong-xian-shi-zai-gan-ma.md\":\"2677e2d0\",\"25.cpu-ji-cun-qi-shi-ru-he-zhuang-ru-jie-gou-ti-de.md\":\"a08c11fd\"}");window.__VP_SITE_DATA__=JSON.parse("{\"lang\":\"en-US\",\"dir\":\"ltr\",\"title\":\"计算机底层的秘密\",\"description\":\"计算机底层的秘密\",\"base\":\"/\",\"head\":[],\"appearance\":true,\"themeConfig\":{\"logo\":\"/logo.jpg\",\"nav\":[{\"text\":\"首页\",\"link\":\"/\"},{\"text\":\"阅读\",\"link\":\"/SUMMARY.md\"},{\"text\":\"原创画作\",\"link\":\"https://www.wonyes.org\"}],\"sidebar\":[{\"text\":\"目录\",\"items\":[{\"text\":\"1.你管这破玩意叫CPU？\",\"link\":\"1.-ni-guan-zhe-po-wan-yi-jiao-cpu.md\"},{\"text\":\"2.你管这破玩意叫线程？\",\"link\":\"2.-ni-guan-zhe-po-wan-yi-jiao-xian-cheng.md\"},{\"text\":\"3.执行I/O操作时底层发生了什么？\",\"link\":\"3.-zhi-hang-io-cao-zuo-shi-di-ceng-fa-sheng-le-shi-mo.md\"},{\"text\":\"4.从小白到高手，你需要理解同步与异步\",\"link\":\"4.-cong-xiao-bai-dao-gao-shou-ni-xu-yao-li-jie-tong-bu-yu-yi-bu.md\"},{\"text\":\"5.你管这破玩意叫IO多路复用？\",\"link\":\"5.-ni-guan-zhe-po-wan-yi-jiao-io-duo-lu-fu-yong.md\"},{\"text\":\"6.CPU是如何理解01二进制的？\",\"link\":\"6.cpu-shi-ru-he-li-jie-01-er-jin-zhi-de.md\"},{\"text\":\"7.CPU空闲时在干嘛？\",\"link\":\"7.cpu-kong-xian-shi-zai-gan-ma.md\"},{\"text\":\"8.编译器是如何工作的？\",\"link\":\"8.-bian-yi-qi-shi-ru-he-gong-zuo-de.md\"},{\"text\":\"9.函数运行时在内存中是什么样子？\",\"link\":\"9.-han-shu-yun-hang-shi-zai-nei-cun-zhong-shi-shi-mo-yang-zi.md\"},{\"text\":\"10.彻底理解回调函数\",\"link\":\"10.-che-di-li-jie-hui-tiao-han-shu.md\"},{\"text\":\"11.自己动手实现malloc内存分配器\",\"link\":\"11.-zi-ji-dong-shou-shi-xian-malloc-nei-cun-fen-pei-qi.md\"},{\"text\":\"12.线程池是如何实现的？\",\"link\":\"12.-xian-cheng-chi-shi-ru-he-shi-xian-de.md\"},{\"text\":\"13.线程安全代码到底是怎么编写的？\",\"link\":\"13.-xian-cheng-an-quan-dai-ma-dao-di-shi-zen-mo-bian-xie-de.md\"},{\"text\":\"14.程序员应如何理解协程\",\"link\":\"14.-cheng-xu-yuan-ying-ru-he-li-jie-xie-cheng.md\"},{\"text\":\"15.十个内存引发的大坑\",\"link\":\"15.-shi-ge-nei-cun-yin-fa-de-da-keng.md\"},{\"text\":\"16.CPU是如何读写内存的？\",\"link\":\"16.cpu-shi-ru-he-du-xie-nei-cun-de.md\"},{\"text\":\"17.CPU与分支预测\",\"link\":\"17.cpu-yu-fen-zhi-yu-ce.md\"},{\"text\":\"18.CPU进化论：复杂指令集的诞生\",\"link\":\"18.cpu-jin-hua-lun-fu-za-zhi-ling-ji-de-dan-sheng.md\"},{\"text\":\"19.CPU进化论：精简指令集的诞生\",\"link\":\"19.cpu-jin-hua-lun-jing-jian-zhi-ling-ji-de-dan-sheng.md\"},{\"text\":\"20.CPU核数与线程数有什么关系？\",\"link\":\"20.cpu-he-shu-yu-xian-cheng-shu-you-shi-mo-guan-xi.md\"},{\"text\":\"21.你管这破玩意叫mmap？\",\"link\":\"21.-ni-guan-zhe-po-wan-yi-jiao-mmap.md\"},{\"text\":\"22.彻底理解零拷贝\",\"link\":\"22.-che-di-li-jie-ling-kao-bei.md\"},{\"text\":\"23.操作系统与内核有什么区别？\",\"link\":\"23.-cao-zuo-xi-tong-yu-nei-he-you-shi-mo-qu-bie.md\"},{\"text\":\"24.彻底理解树的递归遍历\",\"link\":\"24.-che-di-li-jie-shu-de-di-gui-bian-li.md\"},{\"text\":\"25.CPU寄存器是如何装入结构体的？\",\"link\":\"25.cpu-ji-cun-qi-shi-ru-he-zhuang-ru-jie-gou-ti-de.md\"},{\"text\":\"26.CPU可以跑多快？从地球到火星的距离告诉你\",\"link\":\"26.cpu-ke-yi-pao-duo-kuai-cong-di-qiu-dao-huo-xing-de-ju-li-gao-su-ni.md\"},{\"text\":\"27.回调函数实现的原理是什么？\",\"link\":\"27.-hui-tiao-han-shu-shi-xian-de-yuan-li-shi-shi-mo.md\"},{\"text\":\"28.程序员还需要理解汇编吗？\",\"link\":\"28.-cheng-xu-yuan-huan-xu-yao-li-jie-hui-bian-ma.md\"},{\"text\":\"29.什么是异步编程？\",\"link\":\"29.-shi-mo-shi-yi-bu-bian-cheng.md\"},{\"text\":\"30.彻底理解C语言中的指针\",\"link\":\"30.-che-di-li-jiecyu-yan-zhong-de-zhi-zhen.md\"},{\"text\":\"31.程序员应如何理解标准库\",\"link\":\"31.-cheng-xu-yuan-ying-ru-he-li-jie-biao-zhun-ku.md\"},{\"text\":\"32.程序员应如何理解头文件？\",\"link\":\"32.-cheng-xu-yuan-ying-ru-he-li-jie-tou-wen-jian.md\"},{\"text\":\"33.程序员应如何理解多态？\",\"link\":\"33.-cheng-xu-yuan-ying-ru-he-li-jie-duo-tai.md\"},{\"text\":\"34.为什么抽象在计算机科学中如此重要？\",\"link\":\"34.-wei-shi-mo-chou-xiang-zai-ji-suan-ji-ke-xue-zhong-ru-ci-zhong-yao.md\"},{\"text\":\"35.彻底理解堆\",\"link\":\"35.-che-di-li-jie-dui.md\"},{\"text\":\"36.彻底理解链表\",\"link\":\"36.-che-di-li-jie-lian-biao.md\"},{\"text\":\"37.知乎回答\",\"link\":\"37.-zhi-hu-hui-da.md\"}]}],\"socialLinks\":[{\"icon\":\"github\",\"link\":\"https://github.com/jianchang512/gitbook\"}]},\"locales\":{},\"scrollOffset\":90,\"cleanUrls\":false}");</script>
    
  </body>
</html>